$version Generated by VerilatedVcd $end
$timescale 1ps $end
 $scope module TOP $end
  $var wire 1 @ clk $end
  $var wire 1 A reset $end
  $var wire 16 B d_out [15:0] $end
  $var wire 3 C Rx_val [2:0] $end
  $var wire 3 D Ry_val [2:0] $end
  $var wire 3 E sel_val [2:0] $end
  $var wire 16 F x_val [15:0] $end
  $var wire 16 G operand_val [15:0] $end
  $var wire 16 H instruction_val [15:0] $end
  $var wire 1 I branch_val $end
  $var wire 1 J run_val $end
  $var wire 1 K done $end
  $scope module top_module $end
   $var wire 1 @ clk $end
   $var wire 1 A reset $end
   $var wire 16 B d_out [15:0] $end
   $var wire 3 C Rx_val [2:0] $end
   $var wire 3 D Ry_val [2:0] $end
   $var wire 3 E sel_val [2:0] $end
   $var wire 16 F x_val [15:0] $end
   $var wire 16 G operand_val [15:0] $end
   $var wire 16 H instruction_val [15:0] $end
   $var wire 1 I branch_val $end
   $var wire 1 J run_val $end
   $var wire 1 K done $end
   $var wire 16 4 instruction [15:0] $end
   $var wire 16 L last_alu_result [15:0] $end
   $var wire 16 M last_alu [15:0] $end
   $var wire 1 S en_pc $end
   $var wire 1 T en_new_pc $end
   $var wire 1 I branch $end
   $var wire 1 5 run $end
   $var wire 1 6 en_branch $end
   $var wire 1 7 en_fetch $end
   $var wire 1 8 en_memory $end
   $var wire 1 N branch_res $end
   $var wire 12 $ pc [11:0] $end
   $var wire 12 O new_pc [11:0] $end
   $scope module branch_logic $end
    $var wire 16 4 instruction [15:0] $end
    $var wire 1 @ clk $end
    $var wire 16 L last_alu_result [15:0] $end
    $var wire 1 6 en_branch $end
    $var wire 12 O new_pc [11:0] $end
    $var wire 1 N branch_res $end
    $var wire 1 I branch $end
   $upscope $end
   $scope module core $end
    $var wire 16 4 instruction [15:0] $end
    $var wire 1 @ clk $end
    $var wire 1 5 run $end
    $var wire 1 A reset $end
    $var wire 1 N branch_res $end
    $var wire 16 M d_out [15:0] $end
    $var wire 3 C Rx_val [2:0] $end
    $var wire 3 D Ry_val [2:0] $end
    $var wire 3 E sel_val [2:0] $end
    $var wire 16 F x_val [15:0] $end
    $var wire 16 G operand_val [15:0] $end
    $var wire 1 K done $end
    $var wire 16 4 reg_i [15:0] $end
    $var wire 16 % reg_c [15:0] $end
    $var wire 16 & reg_s [15:0] $end
    $var wire 16 ' registers[0] [15:0] $end
    $var wire 16 ( registers[1] [15:0] $end
    $var wire 16 ) registers[2] [15:0] $end
    $var wire 16 * registers[3] [15:0] $end
    $var wire 16 + registers[4] [15:0] $end
    $var wire 16 , registers[5] [15:0] $end
    $var wire 16 - registers[6] [15:0] $end
    $var wire 16 . registers[7] [15:0] $end
    $var wire 1 P en_c $end
    $var wire 1 Q en_s $end
    $var wire 32 / cpp_result [31:0] $end
    $var wire 3 9 Rx [2:0] $end
    $var wire 3 : Ry [2:0] $end
    $var wire 3 ; sel [2:0] $end
    $var wire 8 R en_reg [7:0] $end
    $var wire 16 M result [15:0] $end
    $var wire 16 0 operand [15:0] $end
    $var wire 2 < format [1:0] $end
    $var wire 32 # i [31:0] $end
    $scope module alu $end
     $var wire 1 @ clk $end
     $var wire 16 & in_a [15:0] $end
     $var wire 16 0 in_b [15:0] $end
     $var wire 3 ; select [2:0] $end
     $var wire 1 5 run $end
     $var wire 16 M alu_out [15:0] $end
     $var wire 32 U add [31:0] $end
     $var wire 32 V sub [31:0] $end
     $var wire 32 W and_op [31:0] $end
     $var wire 32 X or_op [31:0] $end
     $var wire 32 Y xor_op [31:0] $end
     $var wire 32 Z shl [31:0] $end
     $var wire 32 [ shr [31:0] $end
     $var wire 32 \ cmp [31:0] $end
    $upscope $end
    $scope module control $end
     $var wire 16 4 instruction [15:0] $end
     $var wire 1 5 run $end
     $var wire 1 @ clk $end
     $var wire 1 A reset $end
     $var wire 1 Q en_s $end
     $var wire 1 P en_c $end
     $var wire 8 R en_reg [7:0] $end
     $var wire 1 K done $end
     $var wire 2 1 state [1:0] $end
     $var wire 2 = next_state [1:0] $end
     $var wire 3 > Rx [2:0] $end
    $upscope $end
   $upscope $end
   $scope module fetch $end
    $var wire 1 @ clk $end
    $var wire 1 A reset $end
    $var wire 1 7 en_pc $end
    $var wire 12 O new_pc [11:0] $end
    $var wire 1 N en_new_pc $end
    $var wire 12 $ pc [11:0] $end
    $var wire 12 2 current_pc [11:0] $end
   $upscope $end
   $scope module fsm $end
    $var wire 1 @ clk $end
    $var wire 1 A reset $end
    $var wire 1 S done $end
    $var wire 1 I branch $end
    $var wire 1 5 run $end
    $var wire 1 6 en_branch $end
    $var wire 1 7 en_fetch $end
    $var wire 1 8 en_memory $end
    $var wire 3 3 state [2:0] $end
    $var wire 3 ? next_state [2:0] $end
    $var wire 32 U IDLE [31:0] $end
    $var wire 32 V CHECK_BRANCH [31:0] $end
    $var wire 32 W FETCH [31:0] $end
    $var wire 32 X CORE_START [31:0] $end
    $var wire 32 Y CORE [31:0] $end
    $var wire 32 Z CORE_END [31:0] $end
   $upscope $end
   $scope module memory $end
    $var wire 1 @ clk $end
    $var wire 1 8 en_memory $end
    $var wire 12 $ pc [11:0] $end
    $var wire 16 4 instruction [15:0] $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b00000000000000000000000000001000 #
b000000000000 $
b0000000000000000 %
b0000000000000000 &
b0000000000000000 '
b0000000000000000 (
b0000000000000000 )
b0000000000000000 *
b0000000000000000 +
b0000000000000000 ,
b0000000000000000 -
b0000000000000000 .
b00000000000000000000000000000000 /
b0000000000000000 0
b00 1
b000000000000 2
b000 3
b0010111101000011 4
05
06
07
18
b001 9
b011 :
b000 ;
b11 <
b01 =
b001 >
b001 ?
1@
0A
b0000000000000000 B
b001 C
b011 D
b000 E
b0000000000000000 F
b0000000000000000 G
b0010111101000011 H
0I
0J
0K
b0000000000000000 L
b0000000000000000 M
0N
b000000000000 O
0P
0Q
b00000000 R
0S
0T
b00000000000000000000000000000000 U
b00000000000000000000000000000001 V
b00000000000000000000000000000010 W
b00000000000000000000000000000011 X
b00000000000000000000000000000100 Y
b00000000000000000000000000000101 Z
b00000000000000000000000000000110 [
b00000000000000000000000000000111 \
#1
0@
#2
b001 3
16
08
b010 ?
1@
#3
0@
#4
b010 3
06
17
b011 ?
1@
#5
0@
#6
b000000000001 $
b000000000001 2
b011 3
b0100000110100111 4
15
07
b010 9
b000 :
b001 ;
b010 >
b100 ?
1@
b010 C
b000 D
b001 E
b0100000110100111 H
1J
#7
0@
#8
b01 1
b100 3
b10 =
b101 ?
1@
1Q
#9
0@
#10
b10 1
b101 3
b11 =
b000 ?
1@
1P
0Q
#11
0@
#12
b11 1
b000 3
05
18
b00 =
b001 ?
1@
0J
1K
0P
b00000100 R
#13
0@
#14
b00 1
b001 3
16
08
b01 =
b010 ?
1@
0K
b00000000 R
#15
0@
#16
b010 3
06
17
b011 ?
1@
#17
0@
#18
b000000000010 $
b000000000010 2
b011 3
b0011101011110001 4
15
07
b001 9
b110 :
b100 ;
b01 <
b001 >
b100 ?
1@
b001 C
b110 D
b100 E
b0011101011110001 H
1J
#19
0@
#20
b01 1
b100 3
b10 =
b101 ?
1@
1Q
#21
0@
#22
b0000000011010111 0
b10 1
b101 3
b11 =
b000 ?
1@
b0000000011010111 B
b0000000011010111 G
b0000000011010111 L
b0000000011010111 M
1P
0Q
#23
0@
#24
b0000000011010111 %
b00000000000000000000000011010111 /
b11 1
b000 3
05
18
b00 =
b001 ?
1@
0J
1K
0P
b00000010 R
#25
0@
