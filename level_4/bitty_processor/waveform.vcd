$version Generated by VerilatedVcd $end
$timescale 1ps $end
 $scope module TOP $end
  $var wire 1 7 clk $end
  $var wire 1 8 reset $end
  $var wire 16 9 instruction [15:0] $end
  $var wire 1 : done $end
  $var wire 16 ; result [15:0] $end
  $var wire 3 < select [2:0] $end
  $scope module top_module $end
   $var wire 1 7 clk $end
   $var wire 1 8 reset $end
   $var wire 16 9 instruction [15:0] $end
   $var wire 1 : done $end
   $var wire 16 ; result [15:0] $end
   $var wire 3 < select [2:0] $end
   $var wire 1 # en_i $end
   $var wire 1 $ en_s $end
   $var wire 1 % en_c $end
   $scope module u_ControlUnit $end
    $var wire 16 9 instruction [15:0] $end
    $var wire 1 7 clk $end
    $var wire 1 8 reset $end
    $var wire 1 $ en_s $end
    $var wire 1 % en_c $end
    $var wire 1 # en_i $end
    $var wire 1 : done $end
    $var wire 16 ; d_out [15:0] $end
    $var wire 3 < select [2:0] $end
    $var wire 32 > IDLE [31:0] $end
    $var wire 32 ? LOAD [31:0] $end
    $var wire 32 @ CALC [31:0] $end
    $var wire 32 A STORE [31:0] $end
    $var wire 32 B DONE [31:0] $end
    $var wire 16 & reg_s [15:0] $end
    $var wire 16 ' reg_c [15:0] $end
    $var wire 16 ( reg_i [15:0] $end
    $var wire 3 ) state [2:0] $end
    $var wire 3 * next_state [2:0] $end
    $var wire 16 + registers[0] [15:0] $end
    $var wire 16 , registers[1] [15:0] $end
    $var wire 16 - registers[2] [15:0] $end
    $var wire 16 . registers[3] [15:0] $end
    $var wire 16 / registers[4] [15:0] $end
    $var wire 16 0 registers[5] [15:0] $end
    $var wire 16 1 registers[6] [15:0] $end
    $var wire 16 2 registers[7] [15:0] $end
    $var wire 3 3 Rx [2:0] $end
    $var wire 3 4 Ry [2:0] $end
    $var wire 3 < sel [2:0] $end
    $var wire 16 5 y [15:0] $end
    $var wire 16 = result [15:0] $end
    $var wire 32 6 i [31:0] $end
    $scope module alu $end
     $var wire 16 & in_a [15:0] $end
     $var wire 16 5 in_b [15:0] $end
     $var wire 3 < select [2:0] $end
     $var wire 16 = alu_out [15:0] $end
     $var wire 32 > add [31:0] $end
     $var wire 32 ? sub [31:0] $end
     $var wire 32 @ and_op [31:0] $end
     $var wire 32 A or_op [31:0] $end
     $var wire 32 B xor_op [31:0] $end
     $var wire 32 C shl [31:0] $end
     $var wire 32 D shr [31:0] $end
     $var wire 32 E cmp [31:0] $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
0#
0$
0%
b0000000000000000 &
b0000000000000000 '
b0000000000000000 (
b000 )
b000 *
b0000000000000000 +
b0000000000000000 ,
b0000000000000000 -
b0000000000000000 .
b0000000000000000 /
b0000000000000000 0
b0000000000000000 1
b0000000000000000 2
b000 3
b000 4
b0000000000000000 5
b00000000000000000000000000000000 6
07
18
b1011110000010000 9
0:
b0000000000000000 ;
b100 <
b0000000000000000 =
b00000000000000000000000000000000 >
b00000000000000000000000000000001 ?
b00000000000000000000000000000010 @
b00000000000000000000000000000011 A
b00000000000000000000000000000100 B
b00000000000000000000000000000101 C
b00000000000000000000000000000110 D
b00000000000000000000000000000111 E
#1
b00000000000000000000000000001000 6
17
#2
07
08
#3
1#
1$
1%
b001 *
17
#5
07
#7
b1011110000010000 (
b001 )
b010 *
b101 3
b111 4
17
#9
07
#11
b010 )
b011 *
17
#13
07
#15
b011 )
b100 *
17
#17
07
#19
b100 )
b000 *
17
1:
#21
07
